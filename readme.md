# Facet Tests

Facet Tests was built as a Ruby testing framework to enable
a developer to test a facet of their code as easily as possible.
The focus is on enabling writing tests that cover as much of the
code as possible while minimizing the friction of writing tests.

The key features offered by Facet Test are:
- test multiple conditions under one test
- the ability to compare complex objects for value equality
- detailed tracing of tested data
- framework for generating a test for every possible combination
    for multiple data points
- framework for quickly generating random values

Code documentation can be generated by running 'yard' at the root
level.

The facet_tests.rb file in spec has tests that should all pass.
They may be useful as 'example' tests as well.

A quick overview of planned features can be seen at 
[Planned Features](./doc/planned_features.md)

## Running Tests

Facet Tests runs at three levels: 
- The frame which is a group of related tests;
- The facet which is designed to test a particular functionality;
- The test, which evaluates to a pass/fail/exception result.

A Frame contains multiple facets, which contain one or more test.
Frames and facets must have a unique string name to describe them.
Tests may optionally have a description, but the expectation is that
under normal circumstances they won't. 

A barebones test script can be created like so:
```
require "facet_tests.rb"

test "Something" do |frame|
    frame.facet "Some Functionality" do |test|
        test.that {true} .is {true}
    end
end
```

Run the script from commandline to process the tests. The -h flag
will print inline help.

Code blocks are used to define the tests. Test yields the Frame
object, and Frame.facet yields a test object that we can use
to then define our tests. This allows multithreading of facets, 
providing the consumer doesn't have out of block code that needs 
to be run in sequence.

Tests are made up using clauses, which can roughly be separated 
into three types:
- Setters are where we run the code producing some output we would like to check
- Matchers receive some code and set the test to pass/fail based on the last set
- Logical update whether a matcher's pass/fail will cause the test to pass fail

### Setters

Setters are used to determine the left hand side (lhs) object that is examined by a 
matcher. The main setter is `that`, which sets the lhs object to the code in the 
provided block. Multiple `that` blocks can be used as a way of providing additional 
logging (log block coming soon), as only the latest `that` block will be used. The lhs
object will persist and can be used in multiple matchers until overwritten by another
setter.

Using `that` without any matchers will turn it into a test for exception - no exception 
and the test will pass. 

`err` can be used where you're *expecting* a test to generate an exception,
and will use the raised exception as the lhs object. If no exception is
generated then `err` will set lhs to nil.

`pick` can be used to temporarily set the lhs object arbitrarily. Once a matcher has been
run, the lhs will reset to what it was before the `pick`. `pick` yields the original object, 
so it can be used to 'pick' an object's property.

Examples:
```
test "Setter Examples" do |t|
    t.that {true} # A no-exception test, will pass
    t.that {false} .that {true} .is {true} # false will be logged, but will be overwritten
        # by the second `that` 
    
    t.err {true} # Will set lhs to nil as no exception is generated
    t.err {notAFunction} # Will set lhs to a NoMethodError

    t.that {[1,2,3]} .pick {|to|to.length} .is {3} .is {[1,2,3]} # Picks the length property
        # of our that object for the first test, and then resets to the original `that` object
        # for the second.
end
```

### Matchers

Matchers are used to determine whether a test passes or fails. A matcher will usually
take a block which will return some value and compare that to the lhs set by the
setter.

`is` does an == comparison between the object returned by the block and 
the lhs object.

`like` checks whether the match and set object have the same content. For simple types,
this is effectively an == check. For complex types, `like` will look at the members 
and return a pass if all members (including checking recursively) match using like. 
This allows the consumer to check arbitrarily complex objects for value equality.
Should a recursive loop be detected, the recursive items are compared using a simple
==. 

`isType` checks whether the type of the lhs object matches the returned object of the block.

Examples:
```
class Complex
    @someVar
end

test "Matchers" do |frame|
    a = Complex.new
    b = Complex.new
    a.someVar = 5
    b.someVar = 5

    frame.facet "is example" do |test|
        test.that {true} .is {true} # pass
        test.that {true} .is {false} # fail
        test.that {a} .is {b} # fail
    end

    frame.facet "like example" do |test|
        test.that {true} .like {true} # pass
        test.that {true} .like {false} # pass
        test.that {a} .like {b} # pass
    end

    frame.facet "isType example" do |test|
        test.that {1} .isType {Integer} # pass
        test.that {1} .isType {Numeric} # pass
        test.that {1} .isType {Float} # fail
    end
```

### Logical

Logical operators allow chaining clauses together and 
manipulating whether a matcher pass/fail will cause a 
test pass/fail. Operators are processed from left to 
right, though a block can be used to group together 
a set of operators. A logical operator must be followed
by either `not`, a matcher or a setter.

`not` inverts the result of a matcher so that a pass
becomes a fail and vice versa.

`or` will mean that so long as either the lhs or rhs
matchers pass, the result is a pass.

`and` requires both the lhs and rhs matchers to be a
pass for the result to be a pass.

`xor` requires either the lhs or rhs matcher to be a 
pass for the result to be a pass. If both are true,
the result is a fail.

Examples:
```
test "Logical" do |frame|
    frame.facet "Basic" do |test|
        test.that {true} .not .is {false}
        test.that {true} .is {true} .or .is {false}
        test.that {true} .is {true} .and .is {true}
        test.that {true} .is {true} .xor .is {false}
    end

    frame.facet "Block and chain" do |test|
        test.that {true} .not {|clauseTest|
            clauseTest.is {true} .xor .is {true} .and .is {true}
        }
    end
end
```

## Reading the Log

The log will record the operations and the data returned for the
setter and matcher clauses (depending on your trace settings).

For any failed test, a list of the clauses will be listed in order,
with clauses that failed colour coded. 

Matcher and setter data is cloned and saved as a snapshot when the 
block is run. This data is then output under the appropriate clause
in the log. At the end of a failed test, a snapshot diff will be
displayed.

The snapshot will look something like this:
```
    that: set
        ParentTest 380
            @@classVal: "CV Demo"
            @@regexDemo: /something.*/
            @someVal: 1
            @child: ChildTest 440
            @someVal: 1

    that: set
        Array 1600
          Array Item 0: 1
          Array Item 1: 2
          Array Item 2: 3

    that: set
        Hash 1600
          Hash Tuple
            @key: :a
            @value: 1
          Hash Tuple
            @key: :b
            @value: 2

    Difference:
        ParentTest
          @child: ChildTest
            @someVal
              @setResult: "1"
              @matchResult: "Array 1680"

    Difference:
        ParentTest
          @child: ChildTest
            @someVal
              @setResult: "1"
              @matchResult: "2"
```

The top object will either be the value for simple types, or have the class 
name followed by the object id. Member and class variables will be displayed 
with @ and @@ accordingly, followed by the value or the class and id for
simple and complex respectively.

Arrays will show Array Item (Index): Item. Hashes will show Hash Tuple with 
a @key and @value for each key=>value pair.

Diff will show the parts of the object that are different. The @setResult
is what was present in the setter object and the @match Result is what
was present in the match object. If the difference is due to two different
types, the types will be shown instead of the values.

## KitchenSink

KitchenSink and MuckyPup can be used to bulk generate tests and data. They
aim to facilitate bulk testing as well as branch testing of code.

KitchenSink is the class that allows the consumer to define a set of data
that they want to test. KitchenSink will then calculate all possible 
combinations of that set, and will run each combination. 

As an example, let's look at testing a logic function that takes three
arguments: a lhs boolean, an operator and a rhs boolean. We want to 
test this function for all possible values for lhs, rhs and an :or
and :and operator.

```
test "KitchenSink" do |frame|
    ks = KitchenSink.new
    ks.data :lhs, true, false
    ks.data :rhs, true, false
    ks.data :op, :or, :and
    ks.result(:result).on(:lhs,:op,:rhs).when(
        [true,:or,true]=>true
        [true,:or,false]=>true
        [false,:or,true]=>true
        [false,:or,false]=>false
        [true,:and,true]=>true
        [true,:and,false]=>false
        [false,:and,true]=>false
        [false,:and,false]=>false
    )

    frame.facet "KitchenSink generated tests" do |test|
        test.that {myOp(data[:lhs],data[:op],data[:rhs])} .is {data[:result]}
    end
end    
```
The data function is used to declare a sequence of data that we want to test.
The first parameter is the name that we access the data when testing and must be unique
All arguments following are the data we want to test. Running the wash function will
yield a hash for each possible combination of called data functions. So if we
had a data function with 2 points and one with three, the wash function would
yield 6 times.

The gen function allows the user to define a block that generates a value when it
is called, instead of having to define values statically. The gen function takes
a name to access the data, a count of the number of times it should be considered
for the purpose of generating all the data combinations and a block which will
return the value for each combination run. In the below example, we are have
some externally defined functions `getSomeVal` which will generate a value for
each test run:

```
test "KitchenSink" do |frame|
    ks = KitchenSink.new
    ks.gen(:someVal,2) do getSomeVal end
    ks.data :static, :one, :two
end   
```

The above KitchenSink's wash function will run four times, effectively treating
the gen function as having two valid combinations to go with the data function.

Group allows a set of data and/or gen functions to generate together, instead of
generating the combination of all of them. The group function requires a count
of the number of data elements to pull from the group and a block utilizing a 
yielded KitchenSinkGroup class where we declare our data or generated data.
The number of data elements must match the group function count parameter. 
Gen functions do not have a count parameter as they use the count from 
the group's count parameter.

```
# Only generates four values as we've grouped two of our values.
test "KitchenSink" do |frame|
    ks = KitchenSink.new
    ks.group(2) do |ksg|
        ksg.data :lhs, true, false
        ksg.data :rhs, true, false
        ksg.gen(:someData) do getSomeValue() end
    ks.data :op, :or, :and
    ks.result(:result).on(:lhs,:op,:rhs).when(
        [true,:or,true]=>true
        [false,:or,false]=>false
        [true,:and,true]=>true
        [false,:and,false]=>false
    )
end    
```

## MuckyPup

MuckyPup is a class that helps with the generation of random data. 
Used in conjunction with the gen function of KitchenSink, it aims
to allow the creation of fuzzing tests for code. 

In the below example, we have a simple function `takeData` that 
should be able to take a range of data. We are running 100 tests
with random data to check that the function doesn't raise an exception.

```
test "KitchenSink" do |frame|
    ks = KitchenSink.new
    mp = MuckyPup.new
    ks.gen(:randVal,100) do mp.genVal end
    frame.facet "Fuzzing" do |test|
        ks.wash do |ksData|
            test.that {takeData(ksData[:randVal])}
        end
    end
end
```

